<style>
  /* Blue highlight for leaf nodes */
  .bc-leaf { color: rgb(0, 0, 88); font-weight: 600; }
  /* Optional: monospaced block to visualize the final printed string */
  .bc-print { white-space: pre-wrap; font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace; }
</style>
<script>
/**
 * A node in the Bracket City tree.
 * - string: the display string (root: initial string; children: question)
 * - answers: array of possible answers (empty for root)
 * - children: array of child nodes
 */
class BCNode {
  constructor(string, answers = []) {
    this.string = String(string);
    this.answers = Array.isArray(answers) ? answers.slice() : [];
    this.children = [];
  }
}

class BracketCity {
  /**
   * @param {string} initialString - the root's string
   */
  constructor(initialString) {
    if (typeof initialString !== 'string') {
      throw new TypeError('initialString must be a string');
    }
    this.root = new BCNode(initialString);
  }

  /**
   * Add one rule line of the form: "a1, a2, ... = question".
   * Finds the FIRST node (BFS) whose string contains a1 and attaches a new child.
   * @param {string} line
   * @returns {BCNode|null} the newly created node or null if no parent matched
   */
  addLine(line) {
    if (typeof line !== 'string') return null;
    const parsed = BracketCity.parseRuleLine(line);
    if (!parsed) return null;
    const { answers, question } = parsed;
    const anchor = answers[0]; // answer1

    // BFS through nodes to find first with string containing answer1
    const queue = [this.root];
    while (queue.length) {
      const node = queue.shift();
      if (node.string.includes(anchor)) {
        const child = new BCNode(question, answers);
        node.children.push(child);
        return child;
      }
      for (const c of node.children) queue.push(c);
    }
    // No parent found; spec says "first one that contains answer1"—if none, we skip.
    return null;
  }

  /**
   * Add many lines at once.
   * Returns an array of results: { line, node } where node is the created node or null.
   * @param {string[]} lines
   */
  addLines(lines) {
    return lines.map(line => ({ line, node: this.addLine(line) }));
  }

  /**
   * Utility: parse "a1, a2, ... = question"
   * Returns {answers: string[], question: string} or null if malformed.
   */
  static parseRuleLine(line) {
    const eqIdx = line.indexOf('=');
    if (eqIdx === -1) return null;

    const left = line.slice(0, eqIdx).trim();
    const right = line.slice(eqIdx + 1).trim();

    if (!left || !right) return null;

    // Split answers by comma, trim whitespace, ignore empties
    const answers = left
      .split(',')
      .map(s => s.trim())
      .filter(s => s.length > 0);

    if (answers.length === 0) return null;

    return { answers, question: right };
  }

  /**
   * Walk the tree (preorder) and invoke a callback for each node.
   * @param {(node: BCNode, depth: number, parent: BCNode|null) => void} visit
   */
  traverse(visit) {
    const dfs = (node, depth, parent) => {
      visit(node, depth, parent);
      for (const c of node.children) dfs(c, depth + 1, node);
    };
    dfs(this.root, 0, null);
  }

  /**
   * Produce a simple text representation (for debugging).
   */
  toString() {
    const lines = [];
    this.traverse((node, depth) => {
      const indent = '  '.repeat(depth);
      const ans = node.answers.length ? ` [answers: ${node.answers.join(', ')}]` : '';
      lines.push(`${indent}- ${node.string}${ans}`);
    });
    return lines.join('\n');
  }

  get_answer(word){
    if (typeof word !== 'string' || !word.trim()) return false;
    const target = word.trim();

    // BFS to find parent-child pair
    const queue = [{ parent: null, node: this.root }];
    while (queue.length) {
      const { parent, node } = queue.shift();

      // If node is a leaf, check its answers
      if (node.children.length === 0) {
        if (node.answers.includes(target)) {
          if (parent) {
            // Remove this node from parent's children
            parent.children = parent.children.filter(c => c !== node);
            return true;
          }
          return false; // root can't be deleted
        }
      }

      // enqueue children
      for (const c of node.children) {
        queue.push({ parent: node, node: c });
      }
    }
    return false; // no match found
  }
}

/* ---------- Example usage ---------- */
(function demo() {
  const bc = new BracketCity("מזל");

  const rules = [
    "מזל = הגורל הטוב שלה הוא להיות בתולה (6 אותיות)",
    "גורל = גבעות שמנווטים בהן, מצפון לבאר שבע",
    "הטוב = ___ הרע והמכוער",
    "בתולה = שלא קיימה יחסי מין",
    "שבע = שורש של המרכז",
    "צפון = חבוי, מוסתר 🐻‍❄️",
    "מכוער = לא יפה",
    "יפה = ירקוני",
    "ירקוני = חייזר אדום וציני, ב => י",
    "הרע = ___ במיעוטו",
    "יחסי = איינשטיין אמר שהכל ___",
    "נווט = פחות שווה מטייס"
  ];

  bc.addLines(rules);

  // Show the built tree in console for quick verification:
  console.log(bc.toString());
  // If you want it on the page:
  const pre = document.createElement('pre');
  pre.textContent = bc.toString();
  document.body.appendChild(pre);
  // Expose for further tinkering in the console:
  window.BracketCity = BracketCity;
  window.bc = bc;
})();
  
function escapeHTML(s) {
  return String(s)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;");
}

/** Replace the first occurrence of 'needle' in 'haystack' with 'replacement'. */
function replaceFirst(haystack, needle, replacement) {
  const idx = haystack.indexOf(needle);
  if (idx === -1) return haystack; // if somehow not found, leave unchanged
  return haystack.slice(0, idx) + replacement + haystack.slice(idx + needle.length);
}

/**
 * Recursively produce the question-style-printing for a node.
 * Returns an HTML string (safe for innerHTML).
 * Leaf nodes are wrapped in <span class="bc-leaf"> ... </span>.
 * Non-leaf nodes: each child's first answer is replaced (first occurrence) by [ childPrinted ].
 */
function questionStylePrint(node) {
  // Base string (escape for safety; we’ll insert bracketed HTML later)
  let rendered = escapeHTML(node.string);

  // Leaf: color it blue and done
  if (!node.children || node.children.length === 0) {
    return `<span class="bc-leaf">${rendered}</span>`;
  }

  // Non-leaf: process children in order
  for (const child of node.children) {
    if (!child.answers || child.answers.length === 0) continue; // defensive
    const anchor = child.answers[0];

    // Child's recursive printed HTML (already bracketed by us below)
    const childPrinted = questionStylePrint(child);
    const bracketed = `[${childPrinted}]`;

    // We must find/replace the FIRST occurrence of the (raw) anchor in the current *rendered*.
    // Note: 'rendered' currently contains HTML entities for <, >, &, but anchors are raw text.
    // To handle safely, we search in the *textual* space, so we need to work in parallel:
    // Approach: since we only escaped &, <, >, and anchors are typical text, we can search for
    // the escaped version of anchor inside 'rendered'.
    const anchorEscaped = escapeHTML(anchor);

    const idx = rendered.indexOf(anchorEscaped);
    if (idx === -1) {
      // If not found (very unlikely due to construction), we leave as-is.
      continue;
    }

    // Do the replacement inside the HTML string
    rendered =
      rendered.slice(0, idx) +
      bracketed +
      rendered.slice(idx + anchorEscaped.length);
  }

  return rendered;
}

// // --- attach to the earlier BracketCity class for convenience ---
// if (typeof window !== 'undefined' && window.BracketCity) {
//   window.BracketCity.prototype.questionStylePrint = function () {
//     return questionStylePrint(this.root);
//   };
// }

/* ---------- Tiny demo (works with the earlier demo tree) ---------- */
// (function demoPrint() {
//   if (!window.BracketCity) return;
//   // Build the same demo tree as before:
//   const bc = new BracketCity("Start with this initial string containing abc and xyz.");
//   const rules = [
//     "abc, def = What is the riddle for abc/def?",
//     "xyz, qqq = Question that anchors on xyz?",
//     "def, ghi = A follow-up that anchors on 'def' (first answer).",
//     "qqq, zzz = Anchors on 'qqq' under the xyz-branch."
//   ];
//   bc.addLines(rules);

//   // Show the question-style result on the page
//   const container = document.createElement('div');
//   container.className = 'bc-print';
//   container.innerHTML = bc.questionStylePrint();
//   document.body.appendChild(container);

//   // Expose function for manual testing in console:
//   window.bc_demo = bc;
// })();
window.myGenerator = function (input){
    ret = window.bc.get_answer(input)
    now_done = !window.bc.root.children
    if (now_done && ret){
        return questionStylePrint(window.bc.root) + "       - זו התשובה היומית! מזל טוב!!!"
    }
    if (now_done && !ret){
        return questionStylePrint(window.bc.root) + "       - זו עדיין התשובה היומית! מזל טוב!!!"
    }
    if (!now_done && !ret){
        return questionStylePrint(window.bc.root) + "       - לא נכון"
    }
    if (!now_done && ret){
        return questionStylePrint(window.bc.root)
    }
};
</script>
